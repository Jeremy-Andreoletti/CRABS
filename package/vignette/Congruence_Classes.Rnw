%\VignetteIndexEntry{Congruence Classes}
%\VignettePackage{ACDC}
%\VignetteKeyword{Documentation}
%\VignetteEngine{knitr::knitr}


\documentclass[12pt]{article}

\usepackage[usenames, dvipsnames]{xcolor}
\usepackage{times}
\usepackage{hyperref}
\hypersetup{pdfpagemode=UseNone} % don't show bookmarks on initial view
\hypersetup{colorlinks, urlcolor={RoyalBlue}, linkcolor={RoyalBlue}, citecolor={SpringGreen}}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{natbib}
\usepackage{placeins}
\usepackage{xspace}

\newcommand{\R}{\textsf{R}\xspace}
\newcommand{\code}{\texttt}
\newcommand{\pkg}{\textsf}
\newcommand{\ACDC}{\pkg{ACDC}\xspace}
\newcommand{\TESS}{\pkg{TESS}\xspace}
\newcommand{\APE}{\pkg{ape}\xspace}
\newcommand{\CODA}{\pkg{coda}\xspace}
\newcommand{\CoMET}{\code{CoMET}\xspace}
\newcommand{\Diversitree}{\pkg{Diversitree}\xspace}
\newcommand{\RevBayes}{\pkg{RevBayes}\xspace}
\newcommand{\RPANDA}{\pkg{RPANDA}\xspace}
\newcommand{\TreePar}{\pkg{TreePar}\xspace}
\newcommand{\TreeSim}{\pkg{TreeSim}\xspace}

% revise margins
\setlength{\headheight}{0.0in}
\setlength{\topmargin}{0.0in}
\setlength{\headsep}{0.0in}
\setlength{\textheight}{8.65in}
\setlength{\footskip}{0.35in}
\setlength{\oddsidemargin}{0.0in}
\setlength{\evensidemargin}{0.0in}
\setlength{\textwidth}{6.5in}

\setlength{\parskip}{6pt}
\setlength{\parindent}{0pt}

\author{Sebastian H{\"o}hna, Bj{\o}rn T. Kopperud and Andrew F. Magee}
\title{Exploration of birth-death congruence classes}

\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle

This is a brief tutorial about how to explore congruence classes of macroevolutionary diversification rates.
Specifically, this tutorial has two main aims/applications:
(1) for a given speciation and extinction rate, you can compute the alternative speciation and extinction rates via the pulled net-diversification rates;
and (2) for some given speciation and extinction rates, which might have been estimated from a phylogenetic tree or provided simply for exploration purposes, you can explore the entire congruence class given some rate limitations (e.g., type of change or min and max rates; see more below).

<<knitr-options, include=FALSE>>=
knitr::opts_chunk$set(fig.width=4, fig.height=4, fig.path='RnwFigs/',
                      warning=FALSE, message=FALSE, tidy=FALSE)
options(width=60)
set.seed(53079239)
# install R/ACDC package if necessary:
#if(!require("ACDC")) install.packages("ACDC", repos="https://cran.us.r-project.org")
@


\newpage
{
\hypersetup{linkcolor=black}
\tableofcontents
}
\newpage


\section{Getting Started}

To get started with exploring congruence classes, you need to have our package \ACDC installed.
Currently, we host the package on GitHub and you need to install it directly from there.

First, make sure that you have a recent version of R installed.
Then, install the \pkg{devtools} R-package, if you don't already have it:
<<inst-devtools, eval=FALSE>>=
install.packages("devtools")
@
Then, make sure that you load the \pkg{devtools} package:
<<load-devtools, eval=FALSE>>=
library(devtools)
@

Now you can install \ACDC directly from GitHub:
<<inst-ACDC, eval=FALSE>>=
install_github("afmagee/ACDC")
@
% Sebastian: This is only for now until we have the package properly on GitHub.
<<local-install-ACDC, echo=FALSE>>=
install.packages("../../package/",type="source",repos=NULL)
@

Note about dependency:
<<load-dependencies, eval=TRUE>>=
library(ape)
library(ggplot2)
library(gridExtra)
library(RColorBrewer)
@


You then load the \ACDC package using the {\tt library} function:
<<load-ACDC>>=
library(ACDC)
@
Now you are ready to use \ACDC to explore congruence classes in macroevolutionary diversification rates.




\section{Overview of functions in \ACDC}

Before we are going to provide some example on how to explore the congruence class, we give you here an overview of the function available in \ACDC.

\begin{table*}[!htbp]
  \caption{Functions available in \ACDC.}
  \begin{center}
      \begin{tabular}{lp{6cm}l}
        \hline\noalign{\smallskip}
        \textbf{Function} & \textbf{Description} & \textbf{Section} \\
        \noalign{\smallskip}
        \hline
        \noalign{\smallskip}
        \code{ACDC.plot.congruence.class.heatmap} & Creates a heatmap of the most frequent rates within the congruence class, given a sample of rate functions from the congruent class (see sample.congruence.class) & Section~\ref{sec:extinction_uniform} \\
        \code{sample.basic.models} & & \\
        \code{sample.congruence.class} & Samples rate functions from the congruence class given a reference speciation and extinction rate function (the true/empirically estimated rate functions). You also need to provide some boundaries/restrictions to the congruence class. The obtained samples can then be inspected visually using \code{ACDC.plot.congruence.class.heatmap} and \code{ACDC.plot.congruence.class.spaghetti} & Section~\ref{sec:extinction_uniform} \\
        \code{sample.rates} & Helps you to randomly sample either a new speciation or extinction rate function given some constraints and/or expected behavior (e.g., autocorrelated vs independent rates) & Section~\ref{sec:extinction_uniform} \\
        \hline
      \end{tabular}
  \end{center}
  \label{tab:Models}
\end{table*}

Below we explain these major functions of \ACDC in detail.
You may want to skip over these discussion if you want to see the examples first.
Nevertheless, we recommend to make yourself familiar with these available functions to get a better idea of how we explore the congruence class.


\subsection{\code{ACDC.plot.congruence.class.heatmap}}


\subsection{\code{ACDC.plot.congruence.class.spaghetti}}


\subsection{\code{sample.basic.models}}
This function is designed to enable easy generation of commonly employed diversification-rate scenarios.
The basic models are specified by the argument \code{model} exponentially increasing/decreasing rates, linearly decreasing rates, episodic (or piecewise constant rates), and Markov random field (MRF) models (constant rates are also possible).
The direction of change (increase or decrease) is controlled by the argument \code{direction}.
The function uses a discrete-time approximation to draw rates, the number of episodes is defined using the argument \code{num.epochs}, which is 100 by default for compatibility with \code{sample.congruence.class}.
So, for example, the code \code{sample.basic.models()}, which uses all defaults, samples exponentially decreasing rates.

By default, the exponential, linear, and episodic models are sampled with an additional random component given by a MRF.
This can be stopped by setting \code{noisy=FALSE}.
The argument \code{MRF.type} allows you to control the type of Markov random field model, the default is ``HSMRF'' for Horseshoe Markov random fields \citep{Magee2020}, which produces jumpier changes.
The alternative, ``GMRF'' for Gaussian Markov random field, produces smoother changes.
This MRF noise allows rates to go up or down, such that \code{direction} gives the overall trend across many sampled rates rather than a guarantee for any one rate.
To change this, and force rates to go one direction while allowing stochastic noise from an MRF, set \code{monotonic=TRUE}.

To have no trends, and pure MRF models, \code{model=``MRF''}.
Note that this means that setting \code{model=``MRF''} and \code{noisy=FALSE} amounts to a constant-rate model (by disabling both trends and stochastic variability).

The argument \code{fc.mean} dictates (more or less) the average amount of change from first to last rate as a fold change.
Specifically, \code{fc.mean} must be a value greater than 1 (1.00...01 is allowed), and \code{direction} determines the direction of change.
If \code{direction=``increasing''}, then \code{fc.mean} defines first/last, while if \code{direction=``decreasing''}, \code{fc.mean} defines last/first.
The default is 3, which is biologically plausible but not the universally best option.
Fold changes are drawn from a Gamma distribution with rate 1.25, offset 1, and a shape parameter that gives the desired mean.

All rate curves are sampled by rejection sampling to guarantee that the rates are all between \code{min.rate} and \code{max.rate}.
By default, rates are assumed to be in [0,10] which is probably the extreme end of plausible variation.
This rejection sampling means that the actual average change may not quite be what it is set to be.
For example if one sets the model to be a decrease through time, sets the rate at present to be 0.5, and the maximum rate to be 0.75, clearly the average fold chane could not be a larger than 1.5x increase.
Be aware, setting rejection limits that make it difficult to sample trajectories can make this function (which is normally quite fast) take a very long time!

The initial rate is drawn from a lognormal distribution with median \code{rate0.median} and log(sigma) = \code{rate0.logsd}, which is to say a Lognormal(log(\code{rate0.median}),\code{rate0.logsd}) distribution.
The default is rates with median 0.1 and a 95\% range covering [0.01,1].
Note that the argument \code{rate0} overrides drawing random starting values if it is set.
This allows sampling speciation rates, as the initial speciation rate must be the same in all replicates.

\subsection{\code{sample.congruence.class}}


\subsection{\code{sample.rates}}




\section{Obtaining speciation and extinction rate functions from empirical phylogenies}

One of the main features and aims of \ACDC is to explore the congruence class for the diversification rates that you estimated using another software or \R package.
Here we provide you some examples using standard software for estimating diversification rates through time, but if your preferred software is not included then you can either specify the diversification rate functions manually, or try to follow our examples in loading the output.

You can jump to the relevant software example and then jump over to the congruence class exploration.



\subsection{Reading in an empirical phylogenetic tree}

First, we assume that you have a phylogenetic tree which you can load into \R.
There are several tutorials on how to do so (e.g., \href{https://cran.r-project.org/web/packages/TESS/vignettes/Bayesian_Diversification_Rate_Analysis.pdf}{\TESS} or \href{https://cran.r-project.org/web/packages/ape/ape.pdf}{\APE}), and we simply refer to these tutorials here.
As an example, we used the \textit{Primates} phylogeny from \cite{Springer2012}.
You can download the data from our \RevBayes \href{https://revbayes.github.io/tutorials/divrate/ebd.html}{tutorial}.
First we need to load the \APE package \citep{Paradis2019}.
<<load-ape>>=
library(ape)
@
Now
<<load-primates>>=
tree <- read.tree(file=paste0("data/primates.tre"))
@
Next, read the software examples to convert the estimated diversification rates into rate functions.


\subsection{Reading \TESS output}\label{sec:TESS_data}

Needs to be written ...

First, load the \TESS package.
<<load-TESS>>=
library(TESS)
@

For some of our plotting, we need the speciation times.
So we extract these from the tree.
<<TESS-read-times>>=
times <- sort( as.numeric( branching.times( tree ) ) )
max_t <- max(times)
@

<<TESS-analysis, echo=TRUE, cache=TRUE>>=
tess.analysis(tree,
              empiricalHyperPriors = TRUE,
              samplingProbability = 1.0,
              numExpectedRateChanges = 2,
              MAX_ITERATIONS = 100000,
              MAX_TIME = 2*60*60,
              MIN_ESS = 625,
              dir = "primates_comet")
@

<<TESS-output, echo=TRUE, cache=TRUE>>=
tess.output <- tess.process.output("primates_comet",
                              numExpectedRateChanges = 2)
@

<<TESS-compute-median, cache=TRUE>>=
est_speciation <- apply(tess.output[["speciation rates"]],
                        2,quantile,prob=0.5)
est_extinction <- apply(tess.output[["extinction rates"]],
                        2,quantile,prob=0.5)
@

<<TESS-functions, cache=TRUE>>=
lambda <- approxfun( tess.output[["intervals"]],
                     c(est_speciation[1],est_speciation) )
mu <- approxfun(     tess.output[["intervals"]],
                     c(est_extinction[1],est_extinction) )
@
Finally, let's have a look at the estimated rate functions.
<<TESS-plot-functions, fig.height=4, fig.width=4, fig.align="center", fig.cap="Estimated speciation and extinction rates using TESS on the primates phylogeny of Springer et al. (2012).">>=
ylim <- c( min(0,est_speciation,est_extinction),
           max(est_speciation,est_extinction))

curve( lambda, xlim=c(max_t, 0), lwd=2, lty=1, col="blue",
       ylim=ylim, main="Primates", xlab="time", ylab="rate",
       cex.main=1.5, cex.lab=1.5 )
curve( mu, add=TRUE, lwd=2, lty=1, col="red" )
legend("bottomleft",legend=c("speciation","extinction"),
       col=c("blue","red"), lty=c(1,1), cex=1.2)
@

For a later use in the tutorial where we want to compare the estimates between different software, we are going to store the rate functions.
<<TESS-rates, cache=TRUE>>=
lambda.TESS <- lambda
mu.TESS     <- mu
@
You could now skip over the next software section and estimate the entire congruence class for these estimated speciation and extinction rates.




\subsection{\TreePar}\label{sec:TreePar_data}

Let us walk here through a very simple \TreePar analysis \citep{Stadler2011}.
For a real publication worthy analysis, you may want to do a more thorough analysis by allowing more possible shifts and a finer grid for the search space.

First, load the \TreePar package.
<<load-TreePar>>=
library(TreePar)
@

\TreePar needs the ages of the phylogeny to perform it's likelihood computation.
We use the \TreePar builtin functionality for this.
<<extract-ages, cache=TRUE>>=
x     <- sort(getx(tree),decreasing=TRUE)
max_t <- max(x)
@
For our toy analysis, we setup some simpler than normal search values.
We specify that there are at most three rate shifts, and that there are ten possible shift points.
For your own analysis, you should most likely increase these values.
We also specify an interval offset of 0.05, which means that in the most recent 5% of the tree age there was no rate shift event.
This is simply for improving the parameter estimation.
<<TreePar-settings>>=
MAX.NUM.SHIFTS  = 4
NUM.INTERVALS   = 20
INTERVAL.OFFSET = 0.05
@
Now we run the full \TreePar maximum likelihood search.
<<TreePar-ML, echo=TRUE, cache=TRUE, results='hide'>>=
res   <- bd.shifts.optim(x,
                         sampling=rep(1,MAX.NUM.SHIFTS+1),
                         grid=max_t/NUM.INTERVALS,
                         start=INTERVAL.OFFSET*max_t,
                         end=max_t,
                         survival=1,
                         posdiv=TRUE)[[2]]
@
Now we have the maximum likelihood estimates for the different number of shifts.
We want to test if $i$ shifts explain the tree significantly better than $i-1$ shifts.
<<TreePar-MLE>>=
best <- 0
for (i in 1:(length(res)-1)) {
    test <- pchisq(2*(res[[i]][1]-res[[i+1]][1]),3)
    #if test>0.95 then i shifts is significantly
    # better than i-1 shifts at a 5% error
    if ( test > 0.95 ) {
        best <- i
    } else {
        break
    }
}
@

<<TreePar-rate-functions>>=
best_result <- res[[best+1]]
speciation <- c()
extinction <- c()
for (i in 1:(best+1)) {
    speciation[i] <- best_result[1+i+(best+1)] /
                     (1-best_result[1+i])
    extinction[i] <- best_result[1+i+(best+1)] /
                     (1/best_result[1+i]-1)
}

if ( best > 0 ) {
    shift_times <- best_result[ (length(best_result)-best+1) :
                                length(best_result)]
    tmp_lambda <- function(x) {
       index <- findInterval(x, shift_times);
       return ( speciation[index+1] )
    }
    tmp_mu     <- function(x) {
       index <- findInterval(x, shift_times);
       return ( extinction[index+1] )
    }
    lambda <- Vectorize(tmp_lambda)
    mu     <- Vectorize(tmp_mu)
} else {
    lambda <- function(x) { return ( rep(speciation[1],length(x)) ) }
    mu     <- function(x) { return ( rep(extinction[1],length(x)) ) }
}
@
Finally, let us have a look at the estimated rate function:
<<TreePar-plot-rate-functions, fig.height=4, fig.width=4, fig.align="center", fig.cap="Estimated speciation and extinction rates using TreePar on the primates phylogeny of Springer et al. (2012).">>=
ylim <- c(min(0,speciation,extinction),max(speciation,extinction))

curve( lambda, xlim=c(max_t, 0), lwd=2, lty=1, col="blue", ylim=ylim, main="primates", xlab="time", ylab="rate", cex.main=1.5, cex.lab=1.5 )
curve( mu, add=TRUE, lwd=2, lty=1, col="red" )
legend("bottomleft",legend=c("speciation","extinction"),
       col=c("blue","red"), lty=c(1,1), cex=1.2)
@

For a later use in the tutorial where we want to compare the estimates between different software, we are going to store the rate functions.
<<TreePar-rates, cache=TRUE>>=
lambda.TreePar <- lambda
mu.TreePar     <- mu
@
You could now skip over the next software section and estimate the entire congruence class for these estimated speciation and extinction rates.







\subsection{The HSMRF model in \RevBayes}

\RevBayes \citep{Hoehna2016b} provides several methods to estimate diversification rates through time.
Here we used the \href{https://revbayes.github.io/tutorials/divrate/ebd.html}{\RevBayes tutorial} using the episodic-birth-death model with a Horseshoe-Markov-Random-Field (HSMRF) prior distribution to estimate diversification rates \citep{Magee2020}.
We assume here that you followed the \RevBayes tutorial and have the output stored as a log-file in the \textit{output} folder.
If you have not run a \RevBayes analysis and wish to explore functionality of the package, we have provided a thinned output file, accessible with \code{data(``HSMRFBDP\_primates'')}.

For some of our plotting, we need the speciation times.
So we extract these from the tree.
<<RevBayes-read-times>>=
times <- sort( as.numeric( branching.times( tree ) ) )
max_t <- max(times)
@

Then we read in the \RevBayes log-file as a simple tab-delimited file.
<<read-RevBayes-output, cache=TRUE>>=
samples <- read.table(file="output/HSMRFBDP_primates.log",
                      stringsAsFactors=FALSE,
                      header=TRUE)
@
Then, from this log-file we want to automatically extract the speciation and extinction rates.
Be careful that you used the same names as we did.
Otherwise you need to modify this code-snippet accordingly.
<<RevBayes-extract-output, cache=TRUE>>=
par_speciation <- samples[, startsWith(names(samples), "speciation_rate.")]
par_extinction <- samples[, startsWith(names(samples), "extinction_rate.")]
@
In principle we can use now the full posterior estimates.
However, in this example we are only interested in the posterior median.
We strongly encourage to use the medians and not the means because the posterior median is a more robust estimate for rates, see \cite{Magee2020}.
<<RevBayes-compute-median, cache=TRUE>>=
est_speciation <- apply(par_speciation, 2, median)
est_extinction <- apply(par_extinction, 2, median)
@
Since we assumed in the tutorial epochs of equal size, we can simply use the \code{approxfun} to create the speciation and extinction rate functions.
<<RevBayes-functions, cache=TRUE>>=
lambda <- approxfun(seq(0, max_t, length.out = length(est_speciation)),
                    est_speciation)
mu <- approxfun(seq(0, max_t, length.out = length(est_extinction)),
                est_extinction)
@
Finally, let's have a look at the estimated rate functions.
<<RevBayes-plot-functions, fig.height=4, fig.width=4, fig.align="center", fig.cap="Estimated speciation and extinction rates using RevBayes on the primates phylogeny of Springer et al. (2012).">>=
ylim <- c( min(0,est_speciation,est_extinction),
           max(est_speciation,est_extinction))

curve( lambda, xlim=c(max_t, 0), lwd=2, lty=1, col="blue",
       ylim=ylim, main="Primates", xlab="time", ylab="rate",
       cex.main=1.5, cex.lab=1.5 )
curve( mu, add=TRUE, lwd=2, lty=1, col="red" )
legend("topleft",legend=c("speciation","extinction"),
       col=c("blue","red"), lty=c(1,1), cex=1.2)
@


For a later use in the tutorial where we want to compare the estimates between different software, we are going to store the rate functions.
<<RevBayes-rates, cache=TRUE>>=
lambda.RevBayes <- lambda
mu.RevBayes     <- mu
@



\section{General background on congruent classes in \ACDC}

One important aspect of the congruence class is that if we know the pulled rates, e.g., the pulled speciation or net-diversification rates, then we only need to know additionally either the new speciation or extinction rate to solve for the missing rate function.
That means, we can compute the pulled diversification rate for our reference model, i.e., using your empirically estimated speciation and extinction rates from the previous sections, and the specify whichever alternative speciation or extinction rate function.
Then we solve the pulled diversification rate equation for this new rate function.

The pulled diversification rate is defined as
\begin{equation}
	r_p(t) = \lambda(t) - \mu(t) + \frac{1}{\lambda(t)} \frac{\text{d}\lambda(t)}{\text{d}t}
\end{equation}
As you may notice, the latter part of this equation entails the derivative of the speciation rate function.
This derivative is only known for simple rate models, for example the constant rate process, linear rates or exponential rates.
(One may solve the derivative for more complex models, but this is usually impossible in general.)

Computationally, it is difficult if not impossible to work with arbitrary continuous rate functions.
Here we follow a common approach to use piecewise-linear rates as an approximation for an arbitrary continuous rate function.
You could create as many intervals as you want, and in our examples we use 1000.
To give you an intuition if 1000 intervals is enough, consider a standard MacBook screen which has a resolution 2560 x 1600 pixels.
That means, if you would use your entire screen width and 2560 intervals, than you couldn't even see a difference to a continuous function because each interval spans exactly one pixel.
(Note also that all plotting programs actually transform continuous functions into discretized function to compute the values at predefined coordinates.)

Since we are using piecewise linear rates, we get (at the interval times) the pulled diversification rate function as
\begin{equation}
	r_p(t_i) = \lambda_i - \mu_i + \frac{1}{\lambda_i} \frac{\lambda_i - \lambda_{i-1}}{\Delta t} \label{eq:pulled_diversification_linear}
\end{equation}
This function is much simpler to compute and is used in our package.

Next, if we know the pulled diversification rate and the new extinction rate, then we can compute the speciation rate as
\begin{equation}
	\lambda_i = \frac{\sqrt{4\times \lambda_{i-1}\times \Delta t + (r_p(t_i) \times \Delta t+\mu_i \times \Delta t - 1)^2} + r_p(t_i)\times \Delta t + \mu_i \times \Delta t - 1}{2\times \Delta t}
\end{equation}
(This equation was obtained by solving the pulled diversification rate for $\lambda_i$.)

Conversely, if we know the speciation rate and the pulled diversification rates, then we can solve Equation~\ref{eq:pulled_diversification_linear} for $\mu$ and get
\begin{equation}
	\mu_i = \lambda_i - r_p(t_i) + \frac{1}{\lambda_i} \frac{\lambda_i - \lambda_{i-1}}{\Delta t}
\end{equation}

These are our fundamental pieces about the congruence classes.
We have the reference model, from which we compute the pulled diversification rate.
Then you can either specify alternative speciation or extinction rate functions, for which we then compute the matching extinction or speciation rate function respectively, or you can explore a space of speciation or extinction rate functions.
We will walk through example of these below.




\section{Exploring alternative rate functions}

The first part of our congruence class exploration focuses on specific alternative models.
That is, we first start by providing a set of alternative extinction rate functions and compute the matching speciation rate functions.
Then, we turn the approach around and specify some alternative speciation rate functions for which we compute the matching extinction rate functions.

We first create a congruence class object which contains all the transformed rate functions (i.e., the net-diversification rate and relative extinction rate) as well as the pulled rates (i.e., the pulled net-diversification and the pulled speciation rate).
<<>>=
my_model = congruence.class( lambda, mu, max_t )
@
The \code{my\_model} includes all the rate functions.
You could plot these yourself, or you can use our simple plotting function.
%<<eval=FALSE>>=
%ACDC.plot.rates( my_model )
%@
%<<include=FALSE>>=
%pdf(file="RnwFigs/Primates_ACDC_Congruence_Class.pdf", width=8,height=8)
%ACDC.plot.rates( my_model )
%dev.off()
%@
%\begin{figure}[h!]
%\centering
%\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruence_Class.pdf}
%\caption{Diversification rate function describing the congruence class. The solid lines show the traditional rates and the dashed lines show the pulled versions of the same rates. We observe that the pulled net-diversification rate has a very steep dip exactly at the time of the increase in the estimated speciation rate. This dip originates from the derivate of the speciation, so it is not surprising that at the time of a steep speciation rate increase, we obtain a steep drop in pulled diversification rate.}
%\label{fig:congruence_class}
%\end{figure}

Now that we have our reference model and congruence class functions, we can explore alternative rate functions within the congruence class.



\subsection{Testing alternative extinction rates}

In this subsection we focus entirely on alternative hypotheses of extinction rates for which we compute the resulting speciation rates.


\subsubsection{Constant extinction rates}

Let us assume that the extinction rate was constant, but at a range of different values.
Specifically, let's assume that the true extinction rate was $\mu(t)=\{0.0,0.025,0.05,0.075,0.1\}$.
For our models we need to create extinction rate functions with these values.
<<>>=
mu_vals <- seq(0,0.1,0.025)
mu1 <- list()
for (i in 1:length(mu_vals)) {
  mu1[[i]] = local({
    mu = mu_vals[i]
    function(t) { rep(mu,length(t)) }
  })
}
@
Now we compute the new speciation rate given the extinction rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.speciation( my_model, list.funcs.mu=mu1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_mu_constant.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_mu_constant.pdf}
\caption{Diversification rate functions within the congruence class assuming different constant extinction rate functions. The dashed lines show the different alternatives that we explored here, and the solid lines represent our reference model. Here we notice that the overall pattern of speciation rates as well as net-diversification rates is fairly robust to alternative constant extinction rates within the congruence class. Only the relative extinction rate changes is value, which is not surprising since we explored different extinction rates.}
\label{fig:congruent_models_mu_constant}
\end{figure}



\subsubsection{Linear decreasing extinction rates}

Next, we will explore different linear rate functions for the extinction rate.
Let us assume that the extinction rate was linear with a range of different slopes.
Specifically, let's assume that the slope was $\alpha=\{0.0,0.0005, \ldots, 0.0002\}$.
We played around with these $\alpha$ values to get reasonable rate functions.
You will need to modify these for your dataset.
Note that in \ACDC, rate functions are defined in backwards time, so while these look like decreasing extinction rates, they are in fact increasing extinction rates when you consider time forward from past to present.

We create extinction rate functions with these $\alpha$ values.
<<>>=
mu_min = 0.01
mu_vals <- seq(0,0.002,0.0005)
mu1 <- list()
for (i in 1:length(mu_vals)) {
  mu1[[i]] = local({
    mu_slope = mu_vals[i]
    function(t) { mu_min + mu_slope * (max_t-t) }
  })
}
@
Now we compute the new speciation rate given the extinction rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.speciation( my_model, list.funcs.mu=mu1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_mu_linear_inc.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_mu_linear_inc.pdf}
\caption{Diversification rate function for different linear extinction rates within the same congruence class. The dashed lines show the different alternatives that we explored here, and the solid lines represent our reference model. We observe that the speciation and net-diversification rates are robust to different linear extinction rates within the congruence. As expected, the relative extinction rate changes because we chose different extinction rates.}
\label{fig:congruent_models_mu_linear_inc}
\end{figure}



\subsubsection{Linear increasing extinction rates}

As in our previous example, we want to explore linear extinction rates but this time we choose linear \emph{increasing} extinction rates.
Specifically, let's assume that the slope was $\alpha=\{0.0,-0.00025, \ldots, -0.0001\}$.
We follow the same approach to define the linear extinction rate functions.
As before, since in \ACDC, rate functions are defined in backwards time, while these look like increasing extinction rates, they are in fact decreasing extinction rates from past to present.
<<>>=
mu_max = 0.1
mu_vals <- seq(0,0.001,0.00025)
mu1 <- list()
for (i in 1:length(mu_vals)) {
  mu1[[i]] = local({
    mu_slope = mu_vals[i]
    function(t) { mu_max - mu_slope * (max_t-t) }
  })
}
@
Now we compute the new speciation rate given the extinction rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.speciation( my_model, list.funcs.mu=mu1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_mu_linear_dec.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_mu_linear_dec.pdf}
\caption{Diversification rate function for linear decreasing extinction rates within the congruence class. The dashed lines show the different alternatives that we explored here, and the solid lines represent our reference model. The results are qualitatively the same to the previous results.}
\label{fig:congruent_models_mu_linear_dec}
\end{figure}



\subsubsection{Exponential decreasing extinction rates}

Next, similar to the linear rate functions we explore some exponential rate functions.
We start here with the exponentially decreasing rates.
Recall that the extinction rate is a function of time such that $\mu(0)$ is the rate at the present and $\mu(1)$ is the rate 1 time unit previously, thus what appear to be exponential increases are in fact decreases.
Specifically, let's assume that the slope was $\alpha=\{0.0,0.005, \ldots, 0.02\}$.
Then, we define the extinction rate function as
<<>>=
mu_max = 0.015
mu_vals <- seq(0,0.02,0.005)
mu1 <- list()
for (i in 1:length(mu_vals)) {
  mu1[[i]] = local({
    mu_factor = mu_vals[i]
    function(t) { mu_max * exp(mu_factor*(max_t-t)) }
  })
}
@
Now we compute the new speciation rate given the extinction rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.speciation( my_model, list.funcs.mu=mu1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_mu_exp_inc.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_mu_exp_inc.pdf}
\caption{Diversification rate functions for exponentially increasing extinction rates within the congruence class. The dashed lines show the different alternatives that we explored here, and the solid lines represent our reference model. As in our previous example, the speciation rate and net-diversification rate are robust to the difference choices of extinction rates.}
\label{fig:congruent_models_mu_exp_inc}
\end{figure}


\subsubsection{Exponential increasing extinction rates}

Finally, we explore exponentially increasing extinction rates.
Specifically, let's assume that the slope was $\alpha=\{0.0,-0.005, \ldots, -0.02\}$.
Recall that the extinction rate is defined backwards in time such that these negative exponents correspond to rates that increase from past to present.
The extinction rate functions are defined as before.
<<>>=
mu_max = 0.04
mu_vals <- seq(0,0.02,0.005)
mu1 <- list()
for (i in 1:length(mu_vals)) {
  mu1[[i]] = local({
    mu_factor = mu_vals[i]
    function(t) { mu_max * exp(-mu_factor*(max_t-t)) }
  })
}
@
Now we compute the new speciation rate given the extinction rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.speciation( my_model, list.funcs.mu=mu1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_mu_exp_dec.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_mu_exp_dec.pdf}
\caption{Diversification rate functions for exponentially decreasing extinction rates within the congruence class. The dashed lines show the different alternatives that we explored here, and the solid lines represent our reference model. Again, as in all our previous examples, the speciation and net-diversification rates are robust to our relatively minor variations in extinction rates. }
\label{fig:congruent_models_mu_exp_dec}
\end{figure}



\subsubsection{2-epoch extinction rates}

Let us assume that the extinction rate changed abruptly at a pre-defined change-point.
We'll try to fix the change-point to the estimated rapid increase in diversification.
Thus, we are modeling the extinction rate as a 2-epoch model.
Furthermore, let us try a range of different factors of increase/decrease.
Specifically, let's assume that the rate increase/decrease was by a factor of $\alpha=\{1,2,4\}$.
Again, we create the list of extinction rate functions.
<<>>=
mu_min = 0.05
t_shift = 5.5
alpha_vals <- seq(-2,2,1)
mu1 <- list()
for (i in 1:length(alpha_vals)) {
  mu1[[i]] = local({
    alpha = alpha_vals[i]
    function(t) { ifelse( t < t_shift, mu_min*2^alpha, mu_min) }
  })
}
@
Now we compute the new speciation rate given the extinction rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.speciation( my_model, list.funcs.mu=mu1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_mu_shift.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_mu_shift.pdf}
\caption{Diversification rate functions for 2-epoch extinction rate functions within the congruence class. The solid line shows the reference model and the dashed lines show the alternative models. We observe no noticeable effect on the overall trend of the derived speciation rates.}
\label{fig:congruent_models_mu_shift}
\end{figure}



\subsubsection{Reversed trend extinction rates}

As a last example, let us explore the case where the extinction rate had the opposite trend to the estimated speciation rate.
That is, if the speciation rate was going up, now we model that the extinction rate goes down.
This should produce the same pattern in the net-diversification rate.
We create this reversed/opposite trend extinction rate function by subtracting the observed speciation rate from some arbitrary baseline (which is necessary to make sure that all extinction rates are positive).
<<>>=
mu_min = 0.5
mu1 <- function(t) mu_min - lambda(t)
@
Now we compute the new speciation rate given the extinction rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.speciation( my_model, func.mu=mu1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_mu_reverse_add.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_mu_reverse_add.pdf}
\caption{Diversification rate functions for our reversed trend additive extinction rate function. The solid line shows the reference model and the dashed lines show the alternative model. Interestingly, the reversed model where the extinction rate goes down instead of the speciation rate going up is not exactly in the congruence class, as we see that the net-diversification rates are not identical. Instead, we see that the speciation rate now drops first just to still increase towards the present.}
\label{fig:congruent_models_mu_rev_trend_add}
\end{figure}


In Figure~\ref{fig:congruent_models_mu_rev_trend_add} we used an additive trend by subtracting the rate.
However, we can also use a multiplicative model by subtracting the log speciation rate and then back-transforming the extinction rate from the log-scale.
<<>>=
mu_min = 0.0075
mu1 <- function(t) exp(log(mu_min) - log(lambda(t)))
@
Now we compute the new speciation rate given the extinction rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.speciation( my_model, func.mu=mu1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_mu_reverse_mult.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_mu_reverse_mult.pdf}
\caption{Diversification rate functions for our reversed multiplicative trend extinction rate function. The solid line shows the reference model and the dashed lines show the alternative model. Interestingly, the derived speciation rate is qualitatively identical except that the speciation rate first decreases before sharply increasing towards the present.}
\label{fig:congruent_models_mu_rev_trend_mult}
\end{figure}


This concludes our brief exploration of different common shapes of extinction rates.
In summary, the speciation and net-diversification rates are mostly robust to our relatively minor variations in extinction rates.
Specifically, the observed pattern of a sharp increase of the speciation rate towards the present is robust to all variation of extinction rates we tested.
Only if we would change the extinction rates in extreme and biologically unrealistic ways, e.g., by allowing the extinction rate to become implausible large, then the extinction rates can overwhelm our observed diversification rate pattern.


\FloatBarrier
\subsection{Testing alternative speciation rates}

Let us now look at the congruence class from the angle of the speciation rates.
Can we also specify different speciation rate function and obtain valid extinction rates?

\subsubsection{Constant speciation rates}

Let us assume that the speciation rate was constant.
However, the congruence class as defined by \cite{Louca2020} dictates that $\lambda(0) = \lambda'(0)$, assuming the same present day sampling fraction for both models.
Thus, there is only one possible constant rate speciation model within the congruence class with $\lambda'(t) = \lambda(0)$
Specifically, let's assume that the true extinction rate was $\mu(t)=\{0.1,0.2,0.3,0.4\}$.
These values represent the magnitude of speciation rates that we estimated.
We follow exactly the same approach as with the extinction rates.
Hence, we start by defining the speciation rate functions.
<<>>=
lambda1 <- function(t) { rep(lambda(0),length(t)) }
@
Now we compute the new extinction rate given the speciation rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.extinction( my_model, func.lambda=lambda1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_lambda_constant.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_lambda_constant.pdf}
\caption{Diversification rate functions for different constant speciation rates within the congruence class. The solid line shows our reference model and the different dashed lines show alternative rates/model. Most interesting, we observe that for the constant speciation rate function we compute an extinction rate that was negative towards the present.}
\label{fig:congruent_models_lambda_constant}
\end{figure}

In this example we observe that for the constant speciation rate function the derived extinction rate function was negative at the present.
A negative extinction rate is clearly unrealistic.
Thus, we can conclude that there is no constant rate speciation rate function within the congruence class.



\subsubsection{Exponential increasing/decreasing speciation rates}

Let us assume that the speciation rate was exponentially increasing or decreasing.
Furthermore, let us try a range of different factors of increase/decrease.
Specifically, let's assume that the rate was $\alpha=\{-0.04,-0.03,\ldots, 0.04\}$.
Again, we create the list of speciation rate functions.
<<>>=
lambda_present = lambda(0)
alpha_vals <- c(seq(0.0,0.04,0.02),seq(-0.5,-0.1,0.2))
lambda1 <- list()
for (i in 1:length(alpha_vals)) {
  lambda1[[i]] = local({
    alpha = alpha_vals[i]
    function(t) { lambda_present * exp(alpha*t) }
  })
}
@
Now we compute the new extinction rate given the speciation rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.extinction( my_model, list.funcs.lambda=lambda1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_lambda_exp.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_lambda_exp.pdf}
\caption{Diversification rate functions for exponentially increasing speciation rate functions within the congruence class. The solid line shows the reference model and the dashed lines show the alternative models. Again, we observe that for all speciation rate functions that the derived extinction rate functions are negative towards the present and/or at some other point in time.}
\label{fig:congruent_models_lambda_exp}
\end{figure}

Our results here for the exponentially increasing speciation functions show again that the derived extinction rates are negative towards the present and/or at another point in time.
Because of the initial condition that all speciation rate functions within the congruence class must have the same value at time $t=0$ (the present), it is very challenging to find other speciation rate functions that have valid extinction rates (i.e., $\mu(t)\leq 0$).
This indicates that the congruence class is much more restrictive for the space of valid speciation rates.


\FloatBarrier
\subsection{Comparing rate estimates from different software}

\subsubsection{\RevBayes as the reference model}

<<RevBayes-reference-congruence-class, cache=TRUE>>=
my_model = congruence.class( lambda.RevBayes, mu.RevBayes, max_t )
@
<<>>=
mu1 <- list()
mu1[[1]] = mu.TESS
mu1[[2]] = mu.TreePar
@
Now we compute the new speciation rate given the extinction rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.speciation( my_model, list.funcs.mu=mu1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_all_software_RevBayes.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_all_software_RevBayes.pdf}
\caption{Diversification rate functions of \TESS and \TreePar with \RevBayes providing the reference model.}
\label{fig:congruent_models_software}
\end{figure}


\subsubsection{\TESS as the reference model}

<<TESS-reference-congruence-class, cache=TRUE>>=
my_model = congruence.class( lambda.TESS, mu.TESS, max_t )
@
<<>>=
mu1 <- list()
mu1[[1]] = mu.RevBayes
mu1[[2]] = mu.TreePar
@
Now we compute the new speciation rate given the extinction rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.speciation( my_model, list.funcs.mu=mu1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_all_software_TESS.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_all_software_TESS.pdf}
\caption{Diversification rate functions of \RevBayes and \TreePar with \TESS providing the reference model.}
\label{fig:congruent_models_software_TESS}
\end{figure}


\subsubsection{\TreePar as the reference model}

<<TreePar-reference-congruence-class, cache=TRUE>>=
my_model = congruence.class( lambda.TreePar, mu.TreePar, max_t )
@
<<>>=
mu1 <- list()
mu1[[1]] = mu.TESS
mu1[[2]] = mu.RevBayes
@
Now we compute the new speciation rate given the extinction rates.
<<eval=TRUE>>=
alt_models <- ACDC.compute.speciation( my_model, list.funcs.mu=mu1 )
@
Let's have a look at these \textit{alternative models}.
<<eval=FALSE>>=
ACDC.plot.congruent.models( alt_models )
@
<<include=FALSE>>=
pdf(file="RnwFigs/Primates_ACDC_Congruent_Models_all_software_TreePar.pdf", width=8,height=8)
ACDC.plot.congruent.models( alt_models )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth,angle=0]{RnwFigs/Primates_ACDC_Congruent_Models_all_software_TreePar.pdf}
\caption{Diversification rate functions of \RevBayes and \TESS with \TreePar providing the reference model.}
\label{fig:congruent_models_software_TreePar}
\end{figure}


\FloatBarrier
\section{Exploring a congruence class}

In theory there are infinitely many speciation and extinction rate functions that are within a congruence class, i.e., all rate functions that have exactly the same likelihood.
It is clearly impossible to enumerate all rate functions.
Instead of trying to explore literally all rate functions, we will sample from these rate functions instead.
This idea is very similar to all sampling based methods.
For example, a posterior distribution with a 95% credible interval between 0.01 and 0.02 contains infinitely many values, but we are we comfortable today with simply sampling values proportional to their posterior probability and looking/plotting the distribution.



In \ACDC we provide several helper functions to sample speciation and extinction rates.

<<rates-at-present>>=
est_lambda0 = lambda(0)
est_mu0     = mu(0)
@



\subsection{General discussion about assumptions on rates}

There are several plausible assumptions that can be made about diversification rates and how these rates vary.
First, you could make assumptions about the magnitude of rate variation, and specifically what are plausible minimum and maximum rates.
Clearly, speciation and extinction rates should not have been smaller than 0, so that could be a safe assumption.

Depending on your study system, you could also assume that rates were never larger than, say, 10 events per lineage per million years.
For example, if you would have a speciation rate of 10 per lineage per million years, then you would expect every lineage to speciate on average every 0.1 million years.
If there would be no extinction, then this would leave the group with just above 22,000 species after only one million years.
So perhaps a rate of 10 could really be seen as an upper bound in systems such as vertebrates and plants.
However, you could argue that there is extinction, and we should better restrict the net-diversification rates to be at most 10.
We get into some more of these restrictions in another section.

The second assumption is about how rates vary over time.
One could argue that if diversification rates were low, say 42 million years ago, then you would assume that the diversification rates were also low 43 million years ago.
This would mean that diversification rates are autocorrelated and do not vary completely arbitrarily over time.

In the next subsections, we explore a few different options of rate variation over time in the next sections, which include:
\begin{enumerate}
  \item HSMRF (autocorrelated) rates
  \item exponentially decreasing rates with stochastic variation
  \item linearly increasing rates with stochastic variation
  \item n-piece episodic models
  \item uncorrelated/independent rates
\end{enumerate}
With the built-in functions \code{sample.basic.models} and \code{sample.rates}, users have freedom to explore these, and many other forms of rate variation.
If these functions are not sufficient, as shown in previous sections, it is easy to customize the sampling to your liking.


\subsection{Temporally autocorrelated extinction rates}\label{sec:extinction_HSMRF}

Here, we generate a variety of alternative extinction rates using HSMRF models \citep{Magee2020}.
When sampling from models, we get random walks, or temporally autocorrelated, extinction rates, and the HSMRF tends to produce random walks that look like piecewise constant functions.
The rates produced here have no overall trend, the median change from past to present is 0.
We use the function \code{sample.basic.models} to construct these rates, which by default assumes that rates are between 0 and 10, though here we change these boundaries slightly to bound the rates to be between 0 and 1.
Our motivation for these values was, that (i) having a maximal expected extinction time per lineage of 1.0 million years seems reasonable from the fossil record, and (ii) we estimated a maximal speciation rate of 0.4, which is clearly smaller than 1.0.

<<sample-function-extinction-HSMRF>>=
extinction_rate_samples <- function() {
   sample.basic.models( num.epochs=100,
                        model="MRF",
                        max.rate=1)
}
@

<<sample-extinction-HSMRF, cache=TRUE, results='hide'>>=
samples <- sample.congruence.class(func_spec0=lambda,
                                   func_ext0=mu,
                                   max.t=max_t,
                                   num.epochs=100,
                                   num.samples=1000,
                                   rate.type="extinction",
                                   sample.extinction.rates=extinction_rate_samples)
@
<<eval=FALSE>>=
p = ACDC.plot.congruence.class.heatmap(func_spec0=lambda,
                               func_ext0=mu,
                               max.t=max_t,
                               sample.grid=samples )
@
<<congruence-class-extinction-HSMRF, chache=TRUE, results='hide', include=FALSE>>=
p = ACDC.plot.congruence.class.heatmap(func_spec0=lambda,
                               func_ext0=mu,
                               max.t=max_t,
                               sample.grid=samples )

ggsave(p,file="RnwFigs/Primates_HSMRF_ACDC_extinction_HSMRF.pdf", width=5,height=10)
@
<<eval=FALSE>>=
ACDC.plot.congruence.class.spaghetti(func_spec0=lambda,
                                     func_ext0=mu,
                                     max.t=max_t,
                                     sample.grid=samples,
                                     max.curves=100 )
@
<<congruence-class-extinction-HSMRF-spaghetti, chache=TRUE, results='hide', include=FALSE>>=
pdf(file="RnwFigs/Primates_HSMRF_ACDC_extinction_HSMRF_speghetti.pdf",width=5,height=10)
ACDC.plot.congruence.class.spaghetti(func_spec0=lambda,
                                     func_ext0=mu,
                                     max.t=max_t,
                                     sample.grid=samples,
                                     max.curves=100 )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.48\textwidth,angle=0]{RnwFigs/Primates_HSMRF_ACDC_extinction_HSMRF.pdf}
\includegraphics[width=0.48\textwidth,angle=0]{RnwFigs/Primates_HSMRF_ACDC_extinction_HSMRF_speghetti.pdf}
\caption{Congruence class assuming HSMRF-distributed extinction rates.}
\label{fig:extinction_HSMRF_spaghetti}
\end{figure}


\subsection{Exponentially decreasing extinction rates}\label{sec:extinction_exponential}

Here, we generate a variety of alternative extinction rates using HSMRF models \citep{Magee2020} with an exponential trend.
We otherwise make the same assumptions as above.
To help the rates we simulate fit within 0 and 1, we set the fold change average to be 2 instead of the default 3.

<<sample-function-extinction-exponential>>=
extinction_rate_samples <- function() {
   sample.basic.models( num.epochs=100,
                        model="exponential",
                        max.rate=1,
                        fc.mean=2)
}
@

<<sample-extinction-exponential, cache=TRUE, results='hide'>>=
samples <- sample.congruence.class(func_spec0=lambda,
                                   func_ext0=mu,
                                   max.t=max_t,
                                   num.epochs=100,
                                   num.samples=1000,
                                   rate.type="extinction",
                                   sample.extinction.rates=extinction_rate_samples)
@
<<eval=FALSE>>=
p = ACDC.plot.congruence.class.heatmap(func_spec0=lambda,
                               func_ext0=mu,
                               max.t=max_t,
                               sample.grid=samples )
@
<<congruence-class-extinction-exponential, chache=TRUE, results='hide', include=FALSE>>=
p = ACDC.plot.congruence.class.heatmap(func_spec0=lambda,
                               func_ext0=mu,
                               max.t=max_t,
                               sample.grid=samples )

ggsave(p,file="RnwFigs/Primates_HSMRF_ACDC_extinction_exponential.pdf", width=5,height=10)
@
<<eval=FALSE>>=
ACDC.plot.congruence.class.spaghetti(func_spec0=lambda,
                                     func_ext0=mu,
                                     max.t=max_t,
                                     sample.grid=samples,
                                     max.curves=100 )
@
<<congruence-class-extinction-exponential-spaghetti, chache=TRUE, results='hide', include=FALSE>>=
pdf(file="RnwFigs/Primates_HSMRF_ACDC_extinction_exponential_speghetti.pdf",width=5,height=10)
ACDC.plot.congruence.class.spaghetti(func_spec0=lambda,
                                     func_ext0=mu,
                                     max.t=max_t,
                                     sample.grid=samples,
                                     max.curves=100 )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.48\textwidth,angle=0]{RnwFigs/Primates_HSMRF_ACDC_extinction_exponential.pdf}
\includegraphics[width=0.48\textwidth,angle=0]{RnwFigs/Primates_HSMRF_ACDC_extinction_exponential_speghetti.pdf}
\caption{Congruence class assuming exponentially changing extinction rates.}
\label{fig:extinction_exponential_spaghetti}
\end{figure}


\subsection{Linearly increasing extinction rates}\label{sec:extinction_linear}

Here, we generate a variety of alternative extinction rates using GMRF models \citep{Magee2020} with a linear trend.
Unlike the exponential section, we here assume that rates have increased, that the increase has been monotonic (there were no decreases, where in the exponential decreases above there were occasional increases), and that the stochastic variability comes from a GMRF.
We otherwise make the same assumptions as above.

<<sample-function-extinction-linear>>=
extinction_rate_samples <- function() {
   sample.basic.models( num.epochs=100,
                        direction="increase",
                        model="linear",
                        monotonic=TRUE,
                        MRF.type="GMRF",
                        max.rate=1,
                        fc.mean=2)
}
@

<<sample-extinction-linear, cache=TRUE, results='hide'>>=
samples <- sample.congruence.class(func_spec0=lambda,
                                   func_ext0=mu,
                                   max.t=max_t,
                                   num.epochs=100,
                                   num.samples=1000,
                                   rate.type="extinction",
                                   sample.extinction.rates=extinction_rate_samples)
@
<<eval=FALSE>>=
p = ACDC.plot.congruence.class.heatmap(func_spec0=lambda,
                               func_ext0=mu,
                               max.t=max_t,
                               sample.grid=samples )
@
<<congruence-class-extinction-linear, chache=TRUE, results='hide', include=FALSE>>=
p = ACDC.plot.congruence.class.heatmap(func_spec0=lambda,
                               func_ext0=mu,
                               max.t=max_t,
                               sample.grid=samples )

ggsave(p,file="RnwFigs/Primates_HSMRF_ACDC_extinction_linear.pdf", width=5,height=10)
@
<<eval=FALSE>>=
ACDC.plot.congruence.class.spaghetti(func_spec0=lambda,
                                     func_ext0=mu,
                                     max.t=max_t,
                                     sample.grid=samples,
                                     max.curves=100 )
@
<<congruence-class-extinction-linear-spaghetti, chache=TRUE, results='hide', include=FALSE>>=
pdf(file="RnwFigs/Primates_HSMRF_ACDC_extinction_linear_speghetti.pdf",width=5,height=10)
ACDC.plot.congruence.class.spaghetti(func_spec0=lambda,
                                     func_ext0=mu,
                                     max.t=max_t,
                                     sample.grid=samples,
                                     max.curves=100 )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.48\textwidth,angle=0]{RnwFigs/Primates_HSMRF_ACDC_extinction_linear.pdf}
\includegraphics[width=0.48\textwidth,angle=0]{RnwFigs/Primates_HSMRF_ACDC_extinction_linear_speghetti.pdf}
\caption{Congruence class assuming linearly changing extinction rates.}
\label{fig:extinction_linear_spaghetti}
\end{figure}


\subsection{Episodic extinction rates}\label{sec:extinction_episodic}

Here, we generate a variety of alternative extinction rates without stochastic noise.
Without noise (\code{noisy=FALSE}), all changes will be in the same direction, here decreases.
The model we generate is an episodic model with 5 rates.
Here, we consider decreasing rates with larger changes from past to present than the previous section.
To help rates stay within the [0,1] bounds we have chosen, we set the rate median at present to be slightly smaller than the default 0.1.

<<sample-function-extinction-episodic>>=
extinction_rate_samples <- function() {
   sample.basic.models( num.epochs=100,
                        direction="decrease",
                        model="episodic5",
                        noisy=FALSE,
                        max.rate=1,
                        fc.mean=4,
                        rate0.median=0.05)
}
@

<<sample-extinction-episodic, cache=TRUE, results='hide'>>=
samples <- sample.congruence.class(func_spec0=lambda,
                                   func_ext0=mu,
                                   max.t=max_t,
                                   num.epochs=100,
                                   num.samples=1000,
                                   rate.type="extinction",
                                   sample.extinction.rates=extinction_rate_samples)
@
<<eval=FALSE>>=
p = ACDC.plot.congruence.class.heatmap(func_spec0=lambda,
                               func_ext0=mu,
                               max.t=max_t,
                               sample.grid=samples )
@
<<congruence-class-extinction-episodic, chache=TRUE, results='hide', include=FALSE>>=
p = ACDC.plot.congruence.class.heatmap(func_spec0=lambda,
                               func_ext0=mu,
                               max.t=max_t,
                               sample.grid=samples )

ggsave(p,file="RnwFigs/Primates_HSMRF_ACDC_extinction_episodic.pdf", width=5,height=10)
@
<<eval=FALSE>>=
ACDC.plot.congruence.class.spaghetti(func_spec0=lambda,
                                     func_ext0=mu,
                                     max.t=max_t,
                                     sample.grid=samples,
                                     max.curves=100 )
@
<<congruence-class-extinction-episodic-spaghetti, chache=TRUE, results='hide', include=FALSE>>=
pdf(file="RnwFigs/Primates_HSMRF_ACDC_extinction_episodic_speghetti.pdf",width=5,height=10)
ACDC.plot.congruence.class.spaghetti(func_spec0=lambda,
                                     func_ext0=mu,
                                     max.t=max_t,
                                     sample.grid=samples,
                                     max.curves=100 )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.48\textwidth,angle=0]{RnwFigs/Primates_HSMRF_ACDC_extinction_episodic.pdf}
\includegraphics[width=0.48\textwidth,angle=0]{RnwFigs/Primates_HSMRF_ACDC_extinction_episodic_speghetti.pdf}
\caption{Congruence class assuming episodicly changing extinction rates.}
\label{fig:extinction_episodic_spaghetti}
\end{figure}




\subsection{A uniform grid of extinction rates}\label{sec:extinction_uniform}

The previous functions used \code{sample.basic.models} to construct a variety of pre-defined hypotheses.
\ACDC also implements \code{sample.rates} to allow more flexibility in user-defined rate functions (and of course the user is free to define their own functions as well).
Here we show this with IID rates.
We assume that the extinction rates could have had any value between 0 and 1 (you could easily pick different numbers here).
Our motivation for these values was, that (i) having a maximal expected extinction time per lineage of 1.0 million years seems reasonable from the fossil record, and (ii) we estimated a maximal speciation rate of 0.4, which is clearly smaller than 1.0.


We furthermore assume that each extinction rate is independent of the previous time interval.
That means that we can model any rate function, even completely crazy zig-zagging functions.

<<sample-function-extinction-uniform>>=
rsample_extinction = function(n) runif(n,0,1)
extinction_rate_samples <- function() {
   sample.rates( num.epochs=100,
                 rsample=rsample_extinction,
                 rsample0=NULL,
                 autocorrelated=FALSE)
}
@

<<sample-extinction-uniform, cache=TRUE, results='hide'>>=
samples <- sample.congruence.class(func_spec0=lambda,
                                   func_ext0=mu,
                                   max.t=max_t,
                                   num.epochs=100,
                                   num.samples=1000,
                                   rate.type="extinction",
                                   sample.extinction.rates=extinction_rate_samples)
@
<<eval=FALSE>>=
p = ACDC.plot.congruence.class.heatmap(func_spec0=lambda,
                               func_ext0=mu,
                               max.t=max_t,
                               sample.grid=samples )
@
<<congruence-class-extinction-uniform, chache=TRUE, results='hide', include=FALSE>>=
p = ACDC.plot.congruence.class.heatmap(func_spec0=lambda,
                               func_ext0=mu,
                               max.t=max_t,
                               sample.grid=samples )

ggsave(p,file="RnwFigs/Primates_HSMRF_ACDC_extinction_uniform.pdf", width=5,height=10)
@
<<eval=FALSE>>=
ACDC.plot.congruence.class.spaghetti(func_spec0=lambda,
                                     func_ext0=mu,
                                     max.t=max_t,
                                     sample.grid=samples,
                                     max.curves=100 )
@
<<congruence-class-extinction-uniform-spaghetti, chache=TRUE, results='hide', include=FALSE>>=
pdf(file="RnwFigs/Primates_HSMRF_ACDC_extinction_uniform_speghetti.pdf",width=5,height=10)
ACDC.plot.congruence.class.spaghetti(func_spec0=lambda,
                                     func_ext0=mu,
                                     max.t=max_t,
                                     sample.grid=samples,
                                     max.curves=100 )
dev.off()
@
\begin{figure}[h!]
\centering
\includegraphics[width=0.48\textwidth,angle=0]{RnwFigs/Primates_HSMRF_ACDC_extinction_uniform.pdf}
\includegraphics[width=0.48\textwidth,angle=0]{RnwFigs/Primates_HSMRF_ACDC_extinction_uniform_speghetti.pdf}
\caption{Congruence class assuming independent and uniformly distributed extinction rates.}
\label{fig:extinction_uniform_spaghetti}
\end{figure}






%\section{R and package versions used}
%
%<<sessionInfo, include=TRUE, echo=TRUE, results='markup'>>=
%sessionInfo()
%@


\clearpage
\bibliographystyle{apalike}
\bibliography{literature}

\end{document}
